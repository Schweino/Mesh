import { BridgeParent } from './bridge-parent';
export class PostmateBridge {
    bridgeParent;
    iframe = null;
    messageHandlers = new Map();
    pendingRequests = new Map();
    handshakeComplete = false;
    constructor(bridgeParent) {
        this.bridgeParent = bridgeParent;
        this.setupMessageHandlers();
    }
    setupMessageHandlers() {
        // Set up the handlers for methods that can be called from child
        this.messageHandlers.set('getWallets', () => this.getWalletsMetadata());
        this.messageHandlers.set('rpc', (request) => this.handleRPC(request));
        this.messageHandlers.set('getProperty', (request) => this.handleGetProperty(request));
        this.messageHandlers.set('refreshDetection', () => {
            this.bridgeParent.refreshDetection();
            return this.getWalletsMetadata();
        });
    }
    async initializeWithIframe(iframe) {
        this.iframe = iframe;
        // Listen for messages from the iframe
        window.addEventListener('message', this.handleMessage.bind(this));
        // Send handshake multiple times to ensure iframe receives it
        let attempts = 0;
        const sendHandshakeWithRetry = () => {
            if (attempts < 10 && !this.handshakeComplete) {
                this.sendHandshake();
                attempts++;
                setTimeout(sendHandshakeWithRetry, 500);
            }
        };
        // Start sending handshakes after a short delay
        setTimeout(sendHandshakeWithRetry, 100);
        console.log('PostmateBridge initialized with existing iframe');
    }
    sendHandshake() {
        if (!this.iframe?.contentWindow) {
            console.error('PostmateBridge: No iframe contentWindow available');
            return;
        }
        console.log('PostmateBridge: Sending handshake to child iframe');
        // Send handshake message to establish connection
        this.iframe.contentWindow.postMessage({
            type: 'postmate-handshake',
            methods: Array.from(this.messageHandlers.keys())
        }, '*');
    }
    async handleMessage(event) {
        // Only handle messages from iframes (not from same window)
        if (event.source === window) {
            return;
        }
        const message = event.data;
        console.log('[PostmateBridge] Received message:', message.type, message.method);
        if (message.type === 'call') {
            // Mark handshake complete when we receive first call from child
            if (!this.handshakeComplete) {
                this.handshakeComplete = true;
            }
            // Handle method call from child
            const handler = this.messageHandlers.get(message.method);
            console.log('[PostmateBridge] Handler found:', !!handler, 'for method:', message.method);
            if (handler) {
                try {
                    const result = await handler(message.args?.[0]);
                    console.log('[PostmateBridge] Handler result:', result);
                    // For RPC calls, the handler returns {id, result} or {id, error}
                    // We need to handle this specially
                    if (message.method === 'rpc') {
                        // Ensure result is an object (should always be for RPC)
                        if (!result || typeof result !== 'object') {
                            // If somehow the RPC didn't return a proper response, send empty result
                            ;
                            event.source?.postMessage({
                                id: message.id,
                                type: 'response',
                                result: { id: message.id, result: undefined }
                            }, event.origin);
                            return;
                        }
                        if (result.error) {
                            // Send error response back to the source
                            ;
                            event.source?.postMessage({
                                id: message.id,
                                type: 'response',
                                error: result.error.message || 'RPC error'
                            }, event.origin);
                            return;
                        }
                        else {
                            // Send the RPC result back to the source
                            // The result object has {id, result} - we send the full object
                            ;
                            event.source?.postMessage({
                                id: message.id,
                                type: 'response',
                                result: result // This is the full RPCResponse
                            }, event.origin);
                            return;
                        }
                    }
                    // For non-RPC calls, send result as-is back to the source
                    try {
                        // Deep clean the result before sending
                        const cleanedResult = JSON.parse(JSON.stringify(result, (_key, value) => {
                            if (typeof value === 'function')
                                return undefined;
                            if (typeof value === 'symbol')
                                return undefined;
                            // Check for function-like objects
                            if (value && typeof value === 'object') {
                                try {
                                    const str = String(value);
                                    if (str.includes('=>') || str.startsWith('function')) {
                                        return undefined;
                                    }
                                }
                                catch {
                                    // Ignore
                                }
                            }
                            return value;
                        }));
                        event.source?.postMessage({
                            id: message.id,
                            type: 'response',
                            result: cleanedResult
                        }, event.origin);
                    }
                    catch (cloneError) {
                        // If we can't clone the result, log the error
                        console.error('Failed to send result:', cloneError);
                        console.log('Problematic result:', result);
                        event.source?.postMessage({
                            id: message.id,
                            type: 'response',
                            error: `Failed to serialize response: ${cloneError.message}`
                        }, event.origin);
                    }
                }
                catch (error) {
                    // Send error response back to the source
                    ;
                    event.source?.postMessage({
                        id: message.id,
                        type: 'response',
                        error: error.message || 'Unknown error'
                    }, event.origin);
                }
            }
        }
        else if (message.type === 'response') {
            // Handle response from child (if we ever call child methods)
            const resolver = this.pendingRequests.get(message.id);
            if (resolver) {
                resolver(message);
                this.pendingRequests.delete(message.id);
            }
        }
    }
    // Commenting out as it's no longer needed with simplified approach
    /*
    private getAvailableMembers(obj: any): {
      functions: string[]
      properties: string[]
    } {
      const functions = new Set<string>()
      const properties = new Set<string>()
  
      // Get own properties safely using property descriptors
      Object.getOwnPropertyNames(obj).forEach(prop => {
        try {
          if (prop === 'constructor') return
  
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop)
          if (descriptor) {
            // Check if it's a direct function property
            if (typeof descriptor.value === 'function') {
              functions.add(prop)
            }
            // If it's not a function, it's a property
            else if (descriptor.value !== undefined) {
              properties.add(prop)
            }
            // Handle getters - check if the getter returns a function
            else if (descriptor.get) {
              try {
                const value = obj[prop]
                // Only add as property if it doesn't return a function
                if (typeof value !== 'function') {
                  properties.add(prop)
                } else {
                  // If getter returns a function, add it to functions
                  functions.add(prop)
                }
              } catch {
                // If we can't access it, skip it
              }
            }
          }
        } catch {
          // Ignore any errors
        }
      })
  
      // Get prototype methods and properties safely
      let proto = Object.getPrototypeOf(obj)
      while (proto && proto !== Object.prototype) {
        Object.getOwnPropertyNames(proto).forEach(prop => {
          try {
            if (prop === 'constructor') return
  
            const descriptor = Object.getOwnPropertyDescriptor(proto, prop)
            if (descriptor) {
              if (typeof descriptor.value === 'function') {
                functions.add(prop)
              } else if (descriptor.get || descriptor.set) {
                // This is a getter/setter property - check what it returns
                try {
                  const value = obj[prop]
                  if (typeof value !== 'function') {
                    properties.add(prop)
                  } else {
                    functions.add(prop)
                  }
                } catch {
                  // If we can't access it, skip it
                }
              }
            }
          } catch {
            // Ignore any errors
          }
        })
        proto = Object.getPrototypeOf(proto)
      }
  
      return {
        functions: Array.from(functions).sort(),
        properties: Array.from(properties).sort()
      }
    }
    */
    getWalletsMetadata() {
        const metadata = {
            eip6963: [],
            walletStandard: [],
            adapters: []
        };
        // Helper function to deep clean property values
        const cleanPropertyValues = (values) => {
            if (!values)
                return {};
            // Remove known problematic properties
            const cleaned = { ...values };
            delete cleaned.rpcEngine;
            delete cleaned._rpcEngine;
            delete cleaned.features;
            try {
                // Try to stringify and parse to ensure it's serializable
                return JSON.parse(JSON.stringify(cleaned, (_key, value) => {
                    // Skip functions completely
                    if (typeof value === 'function') {
                        return undefined;
                    }
                    // Check if value has a toString that looks like a function
                    if (value && typeof value === 'object') {
                        const stringified = String(value);
                        if (stringified.includes('=>') ||
                            stringified.startsWith('function')) {
                            return undefined;
                        }
                    }
                    return value;
                }));
            }
            catch {
                // If that fails, do manual cleaning
                const cleaned = {};
                for (const key in values) {
                    const value = values[key];
                    // Skip functions and undefined values
                    if (typeof value !== 'function' && value !== undefined) {
                        // Additional check for function-like strings
                        const stringified = String(value);
                        if (!stringified.includes('=>') &&
                            !stringified.startsWith('function')) {
                            cleaned[key] = value;
                        }
                    }
                }
                return cleaned;
            }
        };
        // Get EIP-6963 wallets with new structure - SIMPLIFIED
        this.bridgeParent.getDetectedEip6963Wallets().forEach((wallet, uuid) => {
            // Only expose essential EIP6963 provider methods
            const essentialFunctions = ['request', 'on', 'removeListener'];
            const availableFunctions = essentialFunctions.filter(fn => typeof wallet.provider[fn] === 'function');
            // No properties needed for EIP6963 providers
            const availableProperties = [];
            const propertyValues = {};
            // Create the wallet entry
            const walletEntry = {
                uuid,
                info: wallet.info,
                availableFunctions,
                availableProperties,
                propertyValues
            };
            // Verify it's serializable before adding
            try {
                JSON.parse(JSON.stringify(walletEntry));
                metadata.eip6963.push(walletEntry);
            }
            catch (e) {
                console.warn(`Skipping wallet ${wallet.info.name} - not serializable`);
            }
        });
        // Get Wallet Standard wallets with new structure - SIMPLIFIED
        this.bridgeParent.getDetectedWalletStandardWallets().forEach(detected => {
            const { wallet, adapter } = detected;
            // Get adapter members and property values - SIMPLIFIED
            const adapterData = (() => {
                try {
                    const solanaAdapter = adapter.getSolanaAdapter();
                    const targetAdapter = adapter.isSolana && solanaAdapter ? solanaAdapter : adapter;
                    // Only expose essential adapter methods and properties
                    const essentialFunctions = [
                        'connect',
                        'signMessage',
                        'sendTransaction'
                    ];
                    const essentialProperties = ['name', 'publicKey'];
                    const availableFunctions = essentialFunctions.filter(fn => typeof targetAdapter[fn] === 'function');
                    const availableProperties = essentialProperties.filter(prop => {
                        try {
                            return targetAdapter[prop] !== undefined;
                        }
                        catch {
                            return false;
                        }
                    });
                    // Get property values for essential properties only
                    const propertyValues = {};
                    essentialProperties.forEach(prop => {
                        try {
                            const value = targetAdapter[prop];
                            if (value !== undefined && typeof value !== 'function') {
                                const serialized = this.serializeResult(value);
                                if (serialized !== undefined) {
                                    propertyValues[prop] = serialized;
                                }
                            }
                        }
                        catch {
                            // Skip properties that can't be accessed or serialized
                        }
                    });
                    return {
                        functions: availableFunctions,
                        properties: availableProperties,
                        propertyValues
                    };
                }
                catch {
                    // If getting members fails, return empty arrays
                    return { functions: [], properties: [], propertyValues: {} };
                }
            })();
            const walletStandardEntry = {
                name: wallet.name,
                icon: typeof wallet.icon === 'string'
                    ? wallet.icon
                    : wallet.icon?.light || '',
                version: wallet.version,
                chains: wallet.chains,
                features: Object.keys(wallet.features),
                availableFunctions: [], // Simplified - no wallet functions needed
                availableProperties: [], // Simplified - no wallet properties needed
                propertyValues: {},
                adapter: {
                    name: adapter.name,
                    icon: adapter.icon,
                    version: adapter.version,
                    chains: adapter.chains,
                    isSolana: adapter.isSolana,
                    connected: adapter.connected,
                    features: adapter.getFeatures(),
                    availableFunctions: adapterData.functions,
                    availableProperties: adapterData.properties,
                    propertyValues: cleanPropertyValues(adapterData.propertyValues)
                }
            };
            // Verify it's serializable before adding
            try {
                JSON.parse(JSON.stringify(walletStandardEntry));
                metadata.walletStandard.push(walletStandardEntry);
            }
            catch (e) {
                console.warn(`Skipping wallet standard ${wallet.name} - not serializable`, e);
            }
        });
        // Final check - try to serialize the entire object
        try {
            JSON.parse(JSON.stringify(metadata));
        }
        catch (e) {
            console.error('Metadata not fully serializable, applying deep clean:', e);
            // If still not serializable, do a deep clean
            const cleanMetadata = JSON.parse(JSON.stringify(metadata, (_key, value) => {
                if (typeof value === 'function')
                    return undefined;
                if (typeof value === 'symbol')
                    return undefined;
                return value;
            }));
            return cleanMetadata;
        }
        return metadata;
    }
    async handleGetProperty(request) {
        try {
            const { target, property } = request;
            let targetObject;
            // Get the target object based on type
            switch (target.type) {
                case 'eip6963': {
                    const eip6963Wallet = this.bridgeParent
                        .getDetectedEip6963Wallets()
                        .get(target.identifier);
                    if (!eip6963Wallet) {
                        throw new Error(`EIP-6963 provider not found: ${target.identifier}`);
                    }
                    targetObject = eip6963Wallet.provider;
                    break;
                }
                case 'wallet-standard': {
                    const walletStandardWallet = this.bridgeParent
                        .getDetectedWalletStandardWallets()
                        .get(target.identifier);
                    if (!walletStandardWallet) {
                        throw new Error(`Wallet Standard wallet not found: ${target.identifier}`);
                    }
                    targetObject = walletStandardWallet.wallet;
                    break;
                }
                case 'adapter': {
                    const walletWithAdapter = this.bridgeParent
                        .getDetectedWalletStandardWallets()
                        .get(target.identifier);
                    if (!walletWithAdapter) {
                        throw new Error(`Adapter not found: ${target.identifier}`);
                    }
                    const standardAdapter = walletWithAdapter.adapter;
                    const solanaAdapter = standardAdapter.getSolanaAdapter();
                    targetObject = solanaAdapter || standardAdapter;
                    break;
                }
                default:
                    throw new Error(`Unknown target type: ${target.type}`);
            }
            // Get the property value
            const value = targetObject[property];
            // Serialize the value (handle non-serializable objects)
            return this.serializeResult(value);
        }
        catch (error) {
            return {
                error: {
                    code: -32603,
                    message: error.message || 'Internal error',
                    data: error.stack
                }
            };
        }
    }
    async handleRPC(request) {
        try {
            const { id, method, params = [], target } = request;
            if (!target) {
                throw new Error('Target not specified in RPC request');
            }
            let targetObject;
            // Get the target object based on type
            switch (target.type) {
                case 'eip6963': {
                    const eip6963Wallet = this.bridgeParent
                        .getDetectedEip6963Wallets()
                        .get(target.identifier);
                    if (!eip6963Wallet) {
                        throw new Error(`EIP-6963 provider not found: ${target.identifier}`);
                    }
                    targetObject = eip6963Wallet.provider;
                    break;
                }
                case 'wallet-standard': {
                    const walletStandardWallet = this.bridgeParent
                        .getDetectedWalletStandardWallets()
                        .get(target.identifier);
                    if (!walletStandardWallet) {
                        throw new Error(`Wallet Standard wallet not found: ${target.identifier}`);
                    }
                    targetObject = walletStandardWallet.wallet;
                    break;
                }
                case 'adapter': {
                    const walletWithAdapter = this.bridgeParent
                        .getDetectedWalletStandardWallets()
                        .get(target.identifier);
                    if (!walletWithAdapter) {
                        throw new Error(`Adapter not found: ${target.identifier}`);
                    }
                    // Get the underlying Solana adapter if available
                    const standardAdapter = walletWithAdapter.adapter;
                    const solanaAdapter = standardAdapter.getSolanaAdapter();
                    // If trying to call a Solana-specific method without a Solana adapter
                    if (!solanaAdapter &&
                        ['connect', 'disconnect', 'sendTransaction'].includes(method)) {
                        throw new Error(`Method '${method}' requires a Solana wallet adapter`);
                    }
                    targetObject = solanaAdapter || standardAdapter;
                    break;
                }
                default:
                    throw new Error(`Unknown target type: ${target.type}`);
            }
            // Check if the method exists
            if (!targetObject[method] || typeof targetObject[method] !== 'function') {
                throw new Error(`Method not found: ${method}`);
            }
            // Call the method
            const result = await targetObject[method](...params);
            // Serialize the result (handle non-serializable objects)
            const serializedResult = this.serializeResult(result);
            return {
                id,
                result: serializedResult
            };
        }
        catch (error) {
            return {
                id: request.id,
                error: {
                    code: -32603,
                    message: error.message || 'Internal error',
                    data: error.stack
                }
            };
        }
    }
    serializeResult(result) {
        // Handle common non-serializable objects
        if (result === null || result === undefined) {
            return result;
        }
        // Skip functions entirely
        if (typeof result === 'function') {
            return undefined;
        }
        // Handle PublicKey objects (Solana)
        if (result &&
            typeof result === 'object' &&
            result.constructor &&
            result.constructor.name === 'PublicKey') {
            return {
                _type: 'PublicKey',
                value: result.toString()
            };
        }
        // Handle BN (BigNumber) objects
        if (result &&
            typeof result === 'object' &&
            result._bn &&
            typeof result.toString === 'function') {
            return {
                _type: 'PublicKey',
                value: result.toString()
            };
        }
        // Handle objects with toBase58 method (another Solana PublicKey pattern)
        if (result &&
            typeof result === 'object' &&
            typeof result.toBase58 === 'function') {
            return {
                _type: 'PublicKey',
                value: result.toBase58()
            };
        }
        // Handle Uint8Array
        if (result instanceof Uint8Array) {
            return {
                _type: 'Uint8Array',
                value: Array.from(result)
            };
        }
        // Handle arrays
        if (Array.isArray(result)) {
            return result.map(item => this.serializeResult(item));
        }
        // Handle objects - but be more careful to avoid circular references
        if (typeof result === 'object') {
            try {
                // Try to convert to JSON first to check if it's serializable
                JSON.stringify(result);
                return result;
            }
            catch {
                // If not directly serializable, try to extract essential properties
                if (typeof result.toString === 'function') {
                    return result.toString();
                }
                // Return a placeholder for non-serializable objects
                return '[Non-serializable Object]';
            }
        }
        return result;
    }
    destroy() {
        if (this.iframe) {
            window.removeEventListener('message', this.handleMessage.bind(this));
            this.iframe = null;
        }
        this.pendingRequests.clear();
    }
}
//# sourceMappingURL=postmate-bridge.js.map