import * as Comlink from 'comlink';
import { getWallets } from '@wallet-standard/app';
import { isWalletAdapterCompatibleStandardWallet } from '@solana/wallet-adapter-base';
import { Connection, Transaction, VersionedTransaction } from '@solana/web3.js';
import { StandardWalletAdapter } from '@solana/wallet-standard-wallet-adapter-base';
export class BridgeParent {
    iframe;
    handshakeComplete = false;
    parentAPI = null;
    endpoint = null;
    constructor(iframe) {
        if (!iframe) {
            throw new Error('BridgeParent requires an iframe element');
        }
        this.iframe = iframe;
        this.initializeConnection();
    }
    async initializeConnection() {
        // Wait for iframe to be ready
        if (!this.iframe || !this.iframe.contentWindow) {
            return;
        }
        const eip6963Wallets = await this.discoverWallets();
        const walletStandardWallets = this.getSolanaWallets();
        this.parentAPI = {
            eip6963Wallets: eip6963Wallets,
            eip6963WalletsReady: true,
            walletStandardWallets: walletStandardWallets,
            walletStandardWalletsReady: true
        };
        // Use Comlink's windowEndpoint with proper cross-origin support
        // For cross-origin, we need to listen on the parent window, not access the iframe's window
        this.endpoint = Comlink.windowEndpoint(this.iframe.contentWindow, window, '*');
        Comlink.expose(this.parentAPI, this.endpoint);
        this.handshakeComplete = true;
    }
    isConnected() {
        return this.handshakeComplete;
    }
    async discoverWallets() {
        return new Promise(resolve => {
            const detectedWallets = [];
            const timeout = 1000; // Wait up to 1 second for wallets to announce
            // Set up listener for wallet announcements
            const handleAnnouncement = (event) => {
                const announcementEvent = event;
                const { info, provider } = announcementEvent.detail;
                // Check if wallet is already detected (by uuid)
                const existingIndex = detectedWallets.findIndex(w => w.uuid === info.uuid);
                if (existingIndex === -1) {
                    detectedWallets.push({
                        uuid: info.uuid,
                        name: info.name,
                        icon: info.icon,
                        rdns: info.rdns,
                        provider
                    });
                }
            };
            // Listen for wallet announcements
            window.addEventListener('eip6963:announceProvider', handleAnnouncement);
            // Request wallets to announce themselves
            window.dispatchEvent(new Event('eip6963:requestProvider'));
            // Clean up and resolve after timeout
            setTimeout(() => {
                window.removeEventListener('eip6963:announceProvider', handleAnnouncement);
                resolve(detectedWallets);
            }, timeout);
        });
    }
    getSolanaWallets() {
        const { get } = getWallets();
        const wallets = get();
        const solanaWallets = [];
        const walletNames = new Set();
        // First, get wallets from Wallet Standard
        for (const wallet of wallets) {
            // Check if this is a Solana wallet
            if (this.isSolanaWallet(wallet)) {
                let adapter;
                if (isWalletAdapterCompatibleStandardWallet(wallet)) {
                    adapter = new StandardWalletAdapter({ wallet });
                }
                solanaWallets.push({
                    uuid: this.generateWalletId(wallet),
                    name: wallet.name,
                    chains: (wallet.chains || []),
                    features: Object.keys(wallet.features),
                    // Expect a TS error, as not all adapter properties are implemented
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    adapter: adapter
                        ? {
                            name: adapter.name,
                            url: adapter.url,
                            icon: adapter.icon,
                            readyState: adapter.readyState,
                            publicKey: Comlink.proxy({
                                get value() {
                                    return adapter.publicKey;
                                },
                                toBase58: async () => {
                                    return adapter.publicKey?.toBase58();
                                },
                                toJSON: async () => {
                                    return adapter.publicKey?.toJSON();
                                },
                                toBytes: async () => {
                                    return adapter.publicKey?.toBytes();
                                },
                                toBuffer: async () => {
                                    return adapter.publicKey?.toBuffer();
                                },
                                toString: async () => {
                                    return adapter.publicKey?.toString();
                                }
                            }),
                            connecting: adapter.connecting,
                            connected: adapter.connected,
                            supportedTransactionVersions: adapter.supportedTransactionVersions,
                            wallet: adapter.wallet,
                            standard: adapter.standard,
                            destroy: async () => await adapter.destroy(),
                            autoConnect: async () => await adapter.autoConnect(),
                            connect: async () => await adapter.connect(),
                            disconnect: async () => await adapter.disconnect(),
                            sendTransaction: async (transaction, connection, options) => await adapter.sendTransaction(transaction, connection, options),
                            signTransaction: async (transaction) => {
                                return adapter.signTransaction !== undefined
                                    ? await adapter.signTransaction(transaction)
                                    : new Error('Adapter does not support signTransaction');
                            },
                            signAllTransactions: async (transactions) => {
                                return adapter.signAllTransactions !== undefined
                                    ? await adapter.signAllTransactions(transactions)
                                    : new Error('Adapter does not support signAllTransactions');
                            },
                            signMessage: async (message) => {
                                return adapter.signMessage !== undefined
                                    ? await adapter.signMessage(message)
                                    : new Error('Adapter does not support signMessage');
                            },
                            signIn: async (input) => {
                                return adapter.signIn !== undefined
                                    ? await adapter.signIn(input)
                                    : new Error('Adapter does not support signIn');
                            },
                            customFunctions: [
                                'sendSerializedTransaction',
                                'signAllSerializedTransactions',
                                'signSerializedTransaction'
                            ],
                            sendSerializedTransaction: async (transaction, rpcUrl) => {
                                const connection = new Connection(rpcUrl);
                                const uint8Array = new Uint8Array(transaction);
                                // Try to deserialize as VersionedTransaction first
                                let deserializedTx;
                                try {
                                    deserializedTx =
                                        VersionedTransaction.deserialize(uint8Array);
                                }
                                catch {
                                    // If that fails, try as legacy Transaction
                                    try {
                                        deserializedTx = Transaction.from(uint8Array);
                                    }
                                    catch {
                                        throw new Error('Failed to deserialize transaction as either versioned or legacy format');
                                    }
                                }
                                return await adapter.sendTransaction(deserializedTx, connection);
                            },
                            signSerializedTransaction: async (transaction) => {
                                if (adapter.signTransaction === undefined) {
                                    return new Error('Adapter does not support signTransaction');
                                }
                                const uint8Array = new Uint8Array(transaction);
                                // Try to deserialize as VersionedTransaction first
                                let deserializedTx;
                                try {
                                    deserializedTx =
                                        VersionedTransaction.deserialize(uint8Array);
                                }
                                catch {
                                    // If that fails, try as legacy Transaction
                                    try {
                                        deserializedTx = Transaction.from(uint8Array);
                                    }
                                    catch {
                                        return new Error('Failed to deserialize transaction as either versioned or legacy format');
                                    }
                                }
                                return await adapter.signTransaction(deserializedTx);
                            },
                            signAllSerializedTransactions: async (transactions) => {
                                if (adapter.signAllTransactions === undefined) {
                                    return new Error('Adapter does not support signAllTransactions');
                                }
                                const deserializedTransactions = [];
                                for (const transaction of transactions) {
                                    const uint8Array = new Uint8Array(transaction);
                                    // Try to deserialize as VersionedTransaction first
                                    let deserializedTx;
                                    try {
                                        deserializedTx =
                                            VersionedTransaction.deserialize(uint8Array);
                                    }
                                    catch {
                                        // If that fails, try as legacy Transaction
                                        try {
                                            deserializedTx = Transaction.from(uint8Array);
                                        }
                                        catch {
                                            return new Error('Failed to deserialize one or more transactions');
                                        }
                                    }
                                    deserializedTransactions.push(deserializedTx);
                                }
                                return await adapter.signAllTransactions(deserializedTransactions);
                            }
                        }
                        : undefined
                });
                walletNames.add(wallet.name);
            }
        }
        return solanaWallets;
    }
    isSolanaWallet(wallet) {
        const chains = wallet.chains || [];
        const hasSolanaChain = chains.some(chain => chain.startsWith('solana:'));
        return hasSolanaChain;
    }
    generateWalletId(wallet) {
        const chain = wallet.chains?.[0] || 'unknown';
        return `${wallet.name}-${chain}`.toLowerCase().replace(/\s+/g, '-');
    }
    destroy() {
        this.handshakeComplete = false;
        if (this.parentAPI) {
            this.parentAPI.eip6963Wallets = [];
            this.parentAPI.walletStandardWallets = [];
            this.parentAPI = null;
        }
        this.endpoint = null;
        this.iframe = null;
    }
}
//# sourceMappingURL=BridgeParent.js.map