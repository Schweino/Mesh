import * as Comlink from 'comlink'
import type { Wallet } from '@wallet-standard/base'
import { getWallets } from '@wallet-standard/app'
import { isWalletAdapterCompatibleStandardWallet } from '@solana/wallet-adapter-base'
import { Connection, Transaction, VersionedTransaction } from '@solana/web3.js'
import { StandardWalletAdapter } from '@solana/wallet-standard-wallet-adapter-base'

export interface EthereumProvider {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  request: (args: { method: string; params?: unknown[] }) => Promise<any>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  on?: (event: string, handler: (...args: any[]) => void) => void
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  removeListener?: (event: string, handler: (...args: any[]) => void) => void
}

interface ExtendedStandardWalletAdapter extends StandardWalletAdapter {
  customFunctions: (
    | 'sendSerializedTransaction'
    | 'signSerializedTransaction'
    | 'signAllSerializedTransactions'
  )[]
  sendSerializedTransaction: (
    transaction: ArrayBufferLike,
    rpcUrl: string
  ) => Promise<string>
  signSerializedTransaction: (
    transaction: ArrayBufferLike
  ) => Promise<Error | Transaction>
  signAllSerializedTransactions: (
    transactions: ArrayBufferLike[]
  ) => Promise<Error | Transaction[]>
}

export interface WalletStandardInfo {
  uuid: string
  name: string
  chains: string[]
  features: string[]
  adapter: ExtendedStandardWalletAdapter | undefined
}

export interface EIP6963ProviderInfo {
  uuid: string
  name: string
  icon: string
  rdns: string
}

export interface EIP6963ProviderDetail {
  info: EIP6963ProviderInfo
  provider: EthereumProvider
}

export interface EIP6963AnnounceProviderEvent extends CustomEvent {
  type: 'eip6963:announceProvider'
  detail: EIP6963ProviderDetail
}

export interface EIP6963RequestProviderEvent extends Event {
  type: 'eip6963:requestProvider'
}

export interface DetectedWallet {
  uuid: string
  name: string
  icon: string
  rdns: string
  provider: EthereumProvider
}

export interface ParentAPI {
  eip6963Wallets: DetectedWallet[]
  eip6963WalletsReady: boolean
  walletStandardWallets: WalletStandardInfo[]
  walletStandardWalletsReady: boolean
}

export class BridgeParent {
  private iframe: HTMLIFrameElement | null
  private handshakeComplete = false
  private parentAPI: ParentAPI | null = null
  private endpoint: Comlink.Endpoint | null = null

  constructor(iframe: HTMLIFrameElement) {
    if (!iframe) {
      throw new Error('BridgeParent requires an iframe element')
    }

    this.iframe = iframe
    this.initializeConnection()
  }

  private async initializeConnection(): Promise<void> {
    // Wait for iframe to be ready
    if (!this.iframe || !this.iframe.contentWindow) {
      return
    }

    const eip6963Wallets = await this.discoverWallets()
    const walletStandardWallets = this.getSolanaWallets()
    this.parentAPI = {
      eip6963Wallets: eip6963Wallets,
      eip6963WalletsReady: true,
      walletStandardWallets: walletStandardWallets,
      walletStandardWalletsReady: true
    }

    // Use Comlink's windowEndpoint with proper cross-origin support
    // For cross-origin, we need to listen on the parent window, not access the iframe's window
    this.endpoint = Comlink.windowEndpoint(
      this.iframe.contentWindow,
      window,
      '*'
    )
    Comlink.expose(this.parentAPI, this.endpoint)

    this.handshakeComplete = true
  }

  isConnected(): boolean {
    return this.handshakeComplete
  }

  private async discoverWallets(): Promise<DetectedWallet[]> {
    return new Promise(resolve => {
      const detectedWallets: DetectedWallet[] = []
      const timeout = 1000 // Wait up to 1 second for wallets to announce

      // Set up listener for wallet announcements
      const handleAnnouncement = (event: Event) => {
        const announcementEvent = event as EIP6963AnnounceProviderEvent
        const { info, provider } = announcementEvent.detail

        // Check if wallet is already detected (by uuid)
        const existingIndex = detectedWallets.findIndex(
          w => w.uuid === info.uuid
        )

        if (existingIndex === -1) {
          detectedWallets.push({
            uuid: info.uuid,
            name: info.name,
            icon: info.icon,
            rdns: info.rdns,
            provider
          })
        }
      }

      // Listen for wallet announcements
      window.addEventListener('eip6963:announceProvider', handleAnnouncement)

      // Request wallets to announce themselves
      window.dispatchEvent(new Event('eip6963:requestProvider'))

      // Clean up and resolve after timeout
      setTimeout(() => {
        window.removeEventListener(
          'eip6963:announceProvider',
          handleAnnouncement
        )
        resolve(detectedWallets)
      }, timeout)
    })
  }

  private getSolanaWallets(): WalletStandardInfo[] {
    const { get } = getWallets()
    const wallets = get()

    const solanaWallets: WalletStandardInfo[] = []
    const walletNames = new Set<string>()

    // First, get wallets from Wallet Standard
    for (const wallet of wallets) {
      // Check if this is a Solana wallet
      if (this.isSolanaWallet(wallet)) {
        let adapter: StandardWalletAdapter | undefined

        if (isWalletAdapterCompatibleStandardWallet(wallet)) {
          adapter = new StandardWalletAdapter({ wallet })
        }

        solanaWallets.push({
          uuid: this.generateWalletId(wallet),
          name: wallet.name,
          chains: (wallet.chains || []) as string[],
          features: Object.keys(wallet.features),
          // Expect a TS error, as not all adapter properties are implemented
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          adapter: adapter
            ? {
                name: adapter.name,
                url: adapter.url,
                icon: adapter.icon,
                readyState: adapter.readyState,
                publicKey: Comlink.proxy({
                  get value() {
                    return adapter.publicKey
                  },
                  toBase58: async () => {
                    return adapter.publicKey?.toBase58()
                  },
                  toJSON: async () => {
                    return adapter.publicKey?.toJSON()
                  },
                  toBytes: async () => {
                    return adapter.publicKey?.toBytes()
                  },
                  toBuffer: async () => {
                    return adapter.publicKey?.toBuffer()
                  },
                  toString: async () => {
                    return adapter.publicKey?.toString()
                  }
                }),
                connecting: adapter.connecting,
                connected: adapter.connected,
                supportedTransactionVersions:
                  adapter.supportedTransactionVersions,
                wallet: adapter.wallet,
                standard: adapter.standard,
                destroy: async () => await adapter.destroy(),
                autoConnect: async () => await adapter.autoConnect(),
                connect: async () => await adapter.connect(),
                disconnect: async () => await adapter.disconnect(),
                sendTransaction: async (transaction, connection, options) =>
                  await adapter.sendTransaction(
                    transaction,
                    connection,
                    options
                  ),
                signTransaction: async transaction => {
                  return adapter.signTransaction !== undefined
                    ? await adapter.signTransaction(transaction)
                    : new Error('Adapter does not support signTransaction')
                },
                signAllTransactions: async transactions => {
                  return adapter.signAllTransactions !== undefined
                    ? await adapter.signAllTransactions(transactions)
                    : new Error('Adapter does not support signAllTransactions')
                },
                signMessage: async message => {
                  return adapter.signMessage !== undefined
                    ? await adapter.signMessage(message)
                    : new Error('Adapter does not support signMessage')
                },
                signIn: async input => {
                  return adapter.signIn !== undefined
                    ? await adapter.signIn(input)
                    : new Error('Adapter does not support signIn')
                },
                customFunctions: [
                  'sendSerializedTransaction',
                  'signAllSerializedTransactions',
                  'signSerializedTransaction'
                ],
                sendSerializedTransaction: async (
                  transaction: ArrayBufferLike,
                  rpcUrl: string
                ) => {
                  const connection = new Connection(rpcUrl)
                  const uint8Array = new Uint8Array(transaction)

                  // Try to deserialize as VersionedTransaction first
                  let deserializedTx: Transaction | VersionedTransaction
                  try {
                    deserializedTx =
                      VersionedTransaction.deserialize(uint8Array)
                  } catch {
                    // If that fails, try as legacy Transaction
                    try {
                      deserializedTx = Transaction.from(uint8Array)
                    } catch {
                      throw new Error(
                        'Failed to deserialize transaction as either versioned or legacy format'
                      )
                    }
                  }

                  return await adapter.sendTransaction(
                    deserializedTx,
                    connection
                  )
                },
                signSerializedTransaction: async (
                  transaction: ArrayBufferLike
                ) => {
                  if (adapter.signTransaction === undefined) {
                    return new Error('Adapter does not support signTransaction')
                  }

                  const uint8Array = new Uint8Array(transaction)

                  // Try to deserialize as VersionedTransaction first
                  let deserializedTx: Transaction | VersionedTransaction
                  try {
                    deserializedTx =
                      VersionedTransaction.deserialize(uint8Array)
                  } catch {
                    // If that fails, try as legacy Transaction
                    try {
                      deserializedTx = Transaction.from(uint8Array)
                    } catch {
                      return new Error(
                        'Failed to deserialize transaction as either versioned or legacy format'
                      )
                    }
                  }

                  return await adapter.signTransaction(deserializedTx)
                },
                signAllSerializedTransactions: async (
                  transactions: ArrayBufferLike[]
                ) => {
                  if (adapter.signAllTransactions === undefined) {
                    return new Error(
                      'Adapter does not support signAllTransactions'
                    )
                  }

                  const deserializedTransactions: (
                    | Transaction
                    | VersionedTransaction
                  )[] = []

                  for (const transaction of transactions) {
                    const uint8Array = new Uint8Array(transaction)

                    // Try to deserialize as VersionedTransaction first
                    let deserializedTx: Transaction | VersionedTransaction
                    try {
                      deserializedTx =
                        VersionedTransaction.deserialize(uint8Array)
                    } catch {
                      // If that fails, try as legacy Transaction
                      try {
                        deserializedTx = Transaction.from(uint8Array)
                      } catch {
                        return new Error(
                          'Failed to deserialize one or more transactions'
                        )
                      }
                    }

                    deserializedTransactions.push(deserializedTx)
                  }

                  return await adapter.signAllTransactions(
                    deserializedTransactions
                  )
                }
              }
            : undefined
        })
        walletNames.add(wallet.name)
      }
    }
    return solanaWallets
  }

  private isSolanaWallet(wallet: Wallet): boolean {
    const chains = wallet.chains || []
    const hasSolanaChain = chains.some(chain => chain.startsWith('solana:'))

    return hasSolanaChain
  }

  private generateWalletId(wallet: Wallet): string {
    const chain = wallet.chains?.[0] || 'unknown'
    return `${wallet.name}-${chain}`.toLowerCase().replace(/\s+/g, '-')
  }

  public destroy(): void {
    this.handshakeComplete = false

    if (this.parentAPI) {
      this.parentAPI.eip6963Wallets = []
      this.parentAPI.walletStandardWallets = []
      this.parentAPI = null
    }
    this.endpoint = null

    this.iframe = null
  }
}
